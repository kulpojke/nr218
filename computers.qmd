---
title: ""
format:
  html:
    theme: quartz
    css: styles.css
bibliography: references.bib
---

# Computers

## What is a computer?
As recently as the World War II era, computer was an occupation, defined in the Oxford English Dictionary as _one who computes; a calculator, reckoner; specifically a person employed to make calculations in an observatory, in surveying, etc._  Modern electronic computers are named after this profession because they have their origins in large-scale mathematical calculations once performed by human computers, In the 1950s the computer was reconstructed to be an electronic data-processing machine rather than a mathematical instrument[ @campbell-kelly2023computer].
  
We will skip through decades of punch cards, tape ribbons, cold war military machinations, the developments of Silicon Valley, etc.. leading to the modern computer (see  @campbell-kelly2023computer if you want more detail).  There are , however, a couple of important developments that will be of importance going forward.

+ The first is the development of the __Unix operating system__ (and C programming language) at Bell Labs during 1969‚Äì1974. The use of C made Unix ‚Äúportable,‚Äù so that it could be implemented on any computer system.  Up until this point, computers were centralized resources.  The clean, minimalist, functional design of Unix made it possible for users to create variants without affecting the inherent reliability of the system. This spawned versions such as the _Berkeley Software Distribution_ (BSD) in 1978, and later in the 1990s Linux [@campbell-kelly2023computer]. Mac OSX is also a Unix Variant [@apple2011osx-unix-users].
+ Another important development occurred in 1980 when IBM contracted Microsoft to create an operation system for their personal computer.  At the time Microsoft did not have an actual product, so they bought one and tweaked if to make MS-DOS.  

Unix variants and Windows are by far the most common operating systems on  general-purpose computers (desktops, laptops, and servers). @fig-os-tree shows the lineage of common operating systems.  GIS applications are almost always run on one of these platforms.  By in large computers with OSs derived from UNIX and MS-DOS behave in the same ways, but there are some important differences (for a simple overview of differences see [this article](https://www.linuxjournal.com/content/linux-vs-windows)).  A few of these differences will come up from time to time during this course.  The computers in the lab are Windows machines (üòê).  Many of you are probably using Macs with OSX (üóø).  Maybe some of you are Linux users (üî•, üíÖ).

![Family tree of modern general purpose operating systems.  With the exception of Windows (which derives from MS-DOS) all widely used modern general purpose OSs are based on UNIX.](img/os_phylogeny.png){#fig-os-tree fig-alt="Schematic showing pointer to a file or memory address" fig-cap=""}

The __definition of a computer that we will use for this class is, _a machine that manipulates data following a list of programmed instructions_.__  With this definition in mind, it seems that in order to take advantages of the capabilities of computers one must understand _data_, and how computers follow  _programmed instructions_.

# Data

A couple of relevant definitions of data taken from the Oxford English Dictionary are:

+ "Related items of (chiefly numerical) information considered collectively, typically obtained by scientific work and used for reference, analysis, or calculation."
+ "Quantities, characters, or symbols on which operations are performed by a computer, considered collectively. Also (in non-technical contexts): information in digital form."

::: {.columns}
::: {.column}

Data is stored on a computer as zeros and ones (too simple, see @tip-example). When you store a file, the data is stored at some physical location on the disk, and a pointer is saved which is later used to find the file (see @fig-pointers). The details of this are managed for you by applications or programming languages by representing this relationship as human readable symbols.

In most modern computers, files are arranged in a hierarchical file system. The standard Linux filesystem is shown in @fig-linux-filesys. In a hierarchal filesystem, files are arranged within nested directories (sometimes called folders). For example,

:::
::: {.column}

![A pointer (_a_) pointing to the memory address associated with a variable (b), i.e., _a_ contains the memory address 1008 of the variable _b_. In this diagram, the computing architecture uses the same address space and data primitive for both pointers and non-pointers; this need not be the case.](img/pointers.svg){#fig-pointers fig-alt="Schematic showing pointer to a file or memory address" fig-cap="A pointer a pointing to the memory address associated with a variable b, i.e., a contains the memory address 1008 of the variable b. In this diagram, the computing architecture uses the same address space and data primitive for both pointers and non-pointers; this need not be the case."}

:::
:::

![The linux filesystem](img/linux-filesystem-hierarchy.png){#fig-linux-filesys fig-alt="The linux filesystem"}

::: {.attribution style="font-size:0.4em"}
Image Source: [Wikimedia /Sven](https://commons.wikimedia.org/w/index.php?curid=8861432)
:::

## Paths

::: {.columns}
::: {.column}

A [___path___]{style="font-size:1.3em"} is a string that uniquely identifies an item in a file system. Generally, a path is composed of directory names, and optionally a filename, all separated by delimiters. @fig-linux-paths shows the path to `index.qmd` in a terminal. The bottom line of the terminal displays `/home/michael/CP/nr218/index.qmd`. This is the _full path_ to `index.qmd`.  The delimiters are the character `/`. If you look back to @fig-os-tree, you see that the root directory is just `/`. The directory called "home" is directly below `/` in the hierarchy, thus the full path to home is `/home` (or `/home/`). Similarly the full path to the directory "michael" is `/home/michael` (or `/home/michael/`) etc... (but, `/home/michael/CP/nr218/index.qmd` would never be written `/home/michael/CP/nr218/index.qmd/` because `index.qmd` is not a directory, it does not contain other files). __In order for an application to use a file, it must know the path to that file.__

:::
::: {.column}


![&nbsp;](img/bash_paths.png){fig-alt="Path to a file shown in a Bash shell." width="90%" style="font-size:0.004em"}  

![Top: Linux terminal showing the full path to index.qmd.   Bottom the same file shown in the GUI file explorer.](img/gui_paths.png){ #fig-linux-paths fig-alt="Path to a file shown in a GUI" width="90%"}

:::
:::

::: {#tip-example .callout-tip}  
## Cross-Referencing a Tip

If you are saying to yourself, "_How are 0s and 1s stored in a computer, that makes no sense, numbers are abstractions but computers are physical objects?_", that is reasonable.  The ones and zeros are actually stored as sites holding an electrical charge, or not, but that is a deeper explanation than we need for this course.
:::

## Volatile and Non-Volatile Memory

Data can be stored on a disk (as we have previously alluded to).  This type of memory is called ___on-disk storage___.  We call on this type of storage _non-volatile_ because when the program using the data is terminated, or the computer is turned off the data persists to be used later.  This is in contrast to ___Random Access Memory___ (RAM), which is _volatile_ (if the program terminates, the data held there is lost).  In RAM the data sits in volatile memory cells addressed by numeric locations; the CPU accesses it directly with very low latency (quickly). All this is managed by the OS via pages and caches.  Only in advanced cases does the user take an interest of the details of this process.

When an application is running, it typically stores the data it is actively using in RAM (or if it is large in temporary files on-disk)  This allows the application to run more quickly.  When the user wants to save changes that are held in these temporary forms of memory they must specify a file to save it to.  In most GUI based applications this is done via the _File_ menu, or using the keyboard shortcut, `Ctrl+S` (`Cmd+S` on macOS). 




relative directories

when you are working data in ram or saved as temporary files, need to save to avoid data loss


### References

::: {#refs}
:::
